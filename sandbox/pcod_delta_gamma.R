
library(TMB)
library(VAST)
library(sp)
library(sdmTMB)
library(here)

# setwd("C:/Users/Chantel.Wetzel/Documents/GitHub/indexwc/sandbox")
here::i_am("pcod_delta_gamma.R")
dir.create(here("doc", "appendix-VAST"), recursive = TRUE)

#We will fit a geostatistical spatiotemporal model with VAST for the purposes of index standardization, following the sdmTMB example. We will use a data set built into the sdmTMB package: trawl survey data for Pacific Cod in Queen Charlotte Sound. The density units are kg/km^2^. Here, X and Y are coordinates in UTM zone 9.
#To specify the mesh used to approximate the spatial process, which is used in the SPDE calculations, we use the k-means method in VAST. Rather than specifying the cutoff distance, meshes in VAST are typically generated by specifying only the number of knots, which we will later pass, along with other model settings to the function make_settings. We will use 205 knots, the same number in the mesh created in the other versions of this appendix.
#For this example, we will include a factor predictor that represents the mean estimate for each time slice. Settings used for index standardization are specified partially by specifying `purpose = "index2"` but we also explicitly provide arguments for these and other key settings here.


FieldConfig <- matrix(c("IID", "IID", "IID", "IID", "IID", "IID"),
  ncol = 2, nrow = 3,
  dimnames = list(
    c("Omega", "Epsilon", "Beta"),
    c("Component_1", "Component_2")
  )
)
FieldConfig
RhoConfig <- c("Beta1" = 0, "Beta2" = 0, "Epsilon1" = 0, "Epsilon2" = 0)

#Unlike in sdmTMB, the fitting and predicting steps are all accomplished with the function `fit_model()` and thus we need to specify the prediction grid (referred to as the "extrapolation grid" in VAST).  Several options are built in for commonly used regions, but in this example we'll need to format the Queen Charlotte Sound grid in sdmTMB to be used in VAST and specify `Region = "User"` in make_setting and `"input_grid" = input_grid` in `fit_model()`.
# get coordinates in geographic coordinates from UTM projection, after changing units to m
qcs_grid_ll <- qcs_grid
qcs_grid_ll$Y <- qcs_grid_ll$Y * 1000
qcs_grid_ll$X <- qcs_grid_ll$X * 1000
# with sp:
sp::coordinates(qcs_grid_ll) <- ~ X + Y
sp::proj4string(qcs_grid_ll) <- CRS("+proj=utm +zone=9")
qcs_grid_ll <- as.data.frame(spTransform(qcs_grid_ll, CRS("+proj=longlat +datum=WGS84")))
# or with sf:
# qcs_grid_ll <- sf::st_as_sf(
#   x = qcs_grid_ll,
#   coords = c("X", "Y"),
#   crs = "+proj=utm +zone=9"
# )
# qcs_grid_ll <- sf::st_transform(qcs_grid_ll, crs = "+proj=longlat +datum=WGS84")

# remove replicate locations for each year and format for VAST
qcs_grid_ll <- subset(qcs_grid_ll, year == min(qcs_grid_ll$year))
input_grid <- cbind(Lat = qcs_grid_ll$Y, Lon = qcs_grid_ll$X, Area_km2 = 4)

settings <- make_settings(
  n_x = 185, # number of vertices in the SPDE mesh
  Region = "User",
  purpose = "index2", # index of abundance with Gamma for positive catches
  fine_scale = TRUE, # use bilinear interpolation from the INLA 'A' matrix
  zone = 9,
  FieldConfig = FieldConfig,
  RhoConfig = RhoConfig,
  ObsModel = c(2, 0), # conventional logit-linked delta-Gamma; c(10, 2) for Tweedie
  bias.correct = FALSE,
  use_anisotropy = FALSE,
  max_cells = Inf, # use all grid cells from the extrapolation grid
  knot_method = "grid" # or "samples"
)


#Next we will fit a GLMM (generalized linear mixed effects model).

# effort is 1 when using CPUE instead of observed weight as the response:
pcod$effort <- 1
if (FALSE) { # to check offset/effort
  set.seed(1)
  pcod$effort <- exp(rnorm(nrow(pcod), mean = 0, sd = 0.2))
}
pcod <- as.data.frame(pcod) # ensure not a tibble

f <- here("doc", "appendix-VAST", "vast-cache.rds")
if (!file.exists(f)) {
  tictoc::tic()
  fit <- fit_model(
    settings = settings,
    Lat_i = pcod[, "lat"],
    Lon_i = pcod[, "lon"],
    t_i = pcod[, "year"],
    b_i = pcod[, "density"],
    a_i = pcod[, "effort"],
    input_grid = input_grid,
    working_dir = paste0(here("doc", "appendix-VAST"), "/")
  )
  tictoc::toc()
  saveRDS(fit, file = f)
} else {
  fit <- readRDS(f)
}

save(fit, file = here("doc/appendix-VAST/vast_out.Rdata"))

#We can look at parameter estimates and their standard errors. First we see estimates from the binomial component and second we see estimates from the positive Gamma component.
fit$parameter_estimates$SD

mesh <- make_mesh(pcod, xy_cols = c("X", "Y"),
  mesh = fit$spatial_list$MeshList$isotropic_mesh)

tictoc::tic()
fit_sdmTMB <- sdmTMB(
  density ~ 0 + as.factor(year), 
  data = pcod, 
  mesh = mesh,
  offset = log(pcod$effort),
  family = delta_gamma(),
  time = "year", 
  silent = FALSE,
  control = sdmTMBcontrol(newton_loops = 1)
)
tictoc::toc()
fit_sdmTMB

plot_betas <- function(vast_model, sdmTMB_model, vast_par = "beta1_ft", sdmTMB_pars = 1) {
  s <- vast_model$parameter_estimates$SD
  vast_est1 <- as.list(s, "Estimate", report = FALSE)
  vast_est2 <- as.list(s, "Estimate", report = TRUE)
  vast_sd1 <- as.list(s, "Std. Error", report = FALSE)
  vast_sd2 <- as.list(s, "Std. Error", report = TRUE)
  sdmTMB_est <- as.list(sdmTMB_model$sd_report, "Estimate", report = FALSE)
  sdmTMB_sd <- as.list(sdmTMB_model$sd_report, "Std. Error", report = FALSE)
  b_year_vast <- vast_est1[[vast_par]][!is.na(vast_sd1[[vast_par]])]
  b_year_vast_se <- vast_sd1[[vast_par]][!is.na(vast_sd1[[vast_par]])]
  years <- sort(unique(pcod$year))
  lwr_vast <- b_year_vast - 2 * b_year_vast_se
  upr_vast <- b_year_vast + 2 * b_year_vast_se
  plot(years, b_year_vast, ylim = range(c(lwr_vast, upr_vast)))
  segments(years, lwr_vast, years, upr_vast)
  years <- years + 0.05
  #if (sdmTMB_pars == 1) {
    points(years, sdmTMB_est$b_j[,sdmTMB_pars])
    segments(years, sdmTMB_est$b_j[,sdmTMB_pars] - 2 * sdmTMB_sd$b_j[,sdmTMB_pars], 
    years, sdmTMB_est$b_j[,sdmTMB_pars] + 2 * sdmTMB_sd$b_j[,sdmTMB_pars],
    col = "red")
  #} else {
  #  points(years, sdmTMB_est$b_j2)
  #     segments(years, sdmTMB_est$b_j2 - 2 * sdmTMB_sd$b_j2, 
  #  years, sdmTMB_est$b_j2 + 2 * sdmTMB_sd$b_j2,
  #  col = "red")
  #}
  legend("topright", legend = c("VAST", "sdmTMB"), 
    col = c("black", "red"), bty = "n", lty = c(1, 1))
}


#We wrote some custom code to extract comparable parameters (not shown above). Here are the annual mean estimates in link space with 95% confidence intervals for the two components to the delta model:
par(mfrow = c(2, 1), cex = 0.8, mar = c(1.5, 1, 1, 1), oma = c(2, 3, 1, 1))
plot_betas(fit, fit_sdmTMB, "beta1_ft", sdmTMB_pars = 1)
plot_betas(fit, fit_sdmTMB, "beta2_ft", sdmTMB_pars = 2)


#While making custom plots of individual elements would require considerable 
#additional code to extract and reformat the necessary components of each output,
#VAST has a wrapper function that generates the typical plots one may want. 
#Here we stick with the default set of plots (`plot_set = 3`); however, one can 
#specify different standard plots to make by changing the setting of this argument 
#(see `?FishStatsUtils::plot_maps` and `?FishStatsUtils::plot_results`).
plot(
  fit,
  check_residuals = FALSE,
  working_dir = paste0(here("doc", "appendix-VAST"), "/")
)

#The saved plots can be perused by browsing the exported image files in the working directory, but here we will read in some key plots as an example. We can start by looking at the location of samples and knots.
knitr::include_graphics(here("doc", "appendix-VAST", "Data_and_knots.png"))

#Then we can look at maps of the predicted population densities (here on the log scale).
knitr::include_graphics(here("doc", "appendix-VAST", "ln_density-predicted.png"))

#And finally the biomass index.
if (file.exists(here("doc", "appendix-VAST", "Index-Biomass.png"))) {
  knitr::include_graphics(here("doc", "appendix-VAST", "Index-Biomass.png"))
}
if (file.exists(here("doc", "appendix-VAST", "Index.png"))) {
  knitr::include_graphics(here("doc", "appendix-VAST", "Index.png"))
}

# We can compare the index we would get using sdmTMB. Since sdmTMB does not have 
# built-in delta models, we need some way of combining the predictions across the 
# two models. Here, we will do that by simulating from the joint parameter precision 
# matrix and calculating the index with those draws. This should be approximately 
# comparable with the bias-corrected index calculated above with VAST.
tictoc::tic()
p <- predict(fit_sdmTMB, newdata = qcs_grid, return_tmb_object = TRUE)
ind <- get_index(p, bias_correct = TRUE, area = rep(4, nrow(qcs_grid)))
tictoc::toc()

save(fit_sdmTMB, p, ind, file = here("doc/appendix-VAST/sdmTMB_out.Rdata"))

#Now, we can compare the indices. 
#<!-- We will read in the VAST index from the `Index.csv` file created by the 
# `plot.fit_model()` method above. -->
library(dplyr)
library(ggplot2)
vast_i <- read.csv(here("doc/appendix-VAST/Index.csv")) %>%
  mutate(index = "VAST", year = as.numeric(Time), est = Estimate, 
    se = Std..Error.for.ln.Estimate.) %>% 
  select(index, year, est, se) %>% 
  mutate(lwr = exp(log(est) + qnorm(0.025) * se)) %>% 
  mutate(upr = exp(log(est) + qnorm(0.975) * se))
sdm_i <- ind %>% mutate(index = "sdmTMB")
both_i <- bind_rows(sdm_i, vast_i) %>% filter(est > 0)
ggplot(both_i, aes(x = year, y = est, ymin = lwr, ymax = upr, colour = index)) + 
  geom_ribbon(alpha = 0.1) +
  geom_line(alpha = 0.8) + 
  ylim(0, max(both_i$upr)) +
  coord_cartesian(expand = FALSE)



plot(ind$est, vast_i$est[vast_i$est != 0]);abline(0, 1)
plot(ind$upr, vast_i$upr[vast_i$est != 0]);abline(0, 1)
plot(ind$lwr, vast_i$lwr[vast_i$est != 0]);abline(0, 1)
(ind$est - vast_i$est[vast_i$est != 0]) / vast_i$est[vast_i$est != 0]
(ind$upr - vast_i$upr[vast_i$est != 0]) / vast_i$upr[vast_i$est != 0]
(ind$lwr - vast_i$lwr[vast_i$est != 0]) / vast_i$lwr[vast_i$est != 0]


plot(both_i[both_i$index == "sdmTMB","year"],
  both_i[both_i$index == "sdmTMB","est"], ylim = c(0, max(both_i$est) * 1.05),
  type = 'l', lwd = 2, ylab = "Index", xlab = "Year")
points(both_i[both_i$index == "sdmTMB","year"],
  both_i[both_i$index == "sdmTMB","est"], col = 1)
lines(both_i[both_i$index == "VAST","year"],
  both_i[both_i$index == "VAST","est"], col = 2, lwd = 2)
points(both_i[both_i$index == "VAST","year"],
  both_i[both_i$index == "VAST","est"], col = 2)

save(both_i, file = here("doc/appendix-VAST/both_indices.Rdata"))